# [37. 解数独](https://leetcode.cn/problems/sudoku-solver)

## 思路

**矩阵型回溯**

```text
for (每个空格) {
    尝试 1~9 的数字：
        如果合法：
            放数字
            dfs(board)
            回溯（还原）
}
```
## 解法
### 回溯

```java
class Solution {
    public void solveSudoku(char[][] board) {
        dfs(board);
    }

    private boolean dfs(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.')
                    continue;
                // 冲突检测
                for (char k = '1'; k <= '9'; k++) {
                    // 冲突检测
                    if (judge(board, i, j, k)) {
                        // 选择
                        board[i][j] = k;
                        // 递归（唯一解，提前结束递归）
                        if (dfs(board)) {
                            return true;
                        }
                        // 回溯
                        board[i][j] = '.';
                    }
                }
                // 1-9 数字都不行
                return false;
            }
        }
        // 题目保证有解
        return true;
    }

    private boolean judge(char[][] board, int i, int j, char k) {
        // 行
        for (int row = 0; row < 9; row++) {
            if (board[row][j] == k) return false;
        }
        // 列
        for (int col = 0; col < 9; col++) {
            if (board[i][col] == k) return false;
        }
        // 宫
        int startRow = (i / 3) * 3;
        int startCol = (j / 3) * 3;
        for (int row = startRow; row < startRow + 3; row++) {
            for (int col = startCol; col < startCol + 3; col++) {
                if (board[row][col] == k) return false;
            }
        }
        return true;
    }
}
```

## 优化