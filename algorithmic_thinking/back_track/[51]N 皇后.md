# [51. N 皇后](https://leetcode.cn/problems/n-queens)

## 思路

**矩阵型（棋盘类）回溯**

**排列型回溯**

增加条件判断：每行放一个，行冲突自动避免，只需解决同列、主对角线、副对角线冲突。

| 对角线类型       | 坐标特征           | 
|-------------|----------------|
| **主对角线（↘）** | `row - col` 相等 |
| **副对角线（↙）** | `row + col` 相等 |


## 解法

### 回溯

```java
class Solution {
    boolean[] cols;
    boolean[] diag1;
    boolean[] diag2;

    List<List<String>> ans = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        cols = new boolean[n];
        diag1 = new boolean[2 * n - 1];
        diag2 = new boolean[2 * n - 1];

        for (char[] row : board) {
            Arrays.fill(row, '.');
        }

        dfs(board, 0);
        return ans;
    }

    private void dfs(char[][] board, int row) {
        int n = board.length;
        // 终止条件
        if (row == n) {
            List<String> tmp = new ArrayList<>();
            for (char[] r : board) {
                tmp.add(new String(r));
            }
            ans.add(tmp);
            return;
        }

        // 遍历选择
        for (int col = 0; col < n; col++) {
            // 条件判断
            // 检查列、主对角线、副对角线是否被占用
            int d1 = row - col + n - 1;
            int d2 = row + col;
            if (cols[col] || diag1[d1] || diag2[d2]) continue;

            //  选择
            board[row][col] = 'Q';
            cols[col] = diag1[d1] = diag2[d2] = true;
            // 递归
            dfs(board, row + 1);
            // 回溯
            board[row][col] = '.';
            cols[col] = diag1[d1] = diag2[d2] = false;
        }
    }
}
```

## 优化