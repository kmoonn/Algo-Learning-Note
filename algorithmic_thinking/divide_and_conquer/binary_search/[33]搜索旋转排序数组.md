# [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array)

## 思路

先用 findMin 找到旋转点（最小值下标），判断目标值落在旋转后的哪一段，使用二分查找。

在任意旋转升序数组中，任意时刻必定有一侧是有序的（左半段或右半段）

## 解法

### 二分查找

**查找旋转点 + 两次二分**

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int i = findMin(nums);

        if (target > nums[n - 1]) {
            return lowerBound(nums, 0, i - 1, target);
        }
        return lowerBound(nums, i, n - 1, target);

    }

    private int findMin(int[] nums) {
        int n = nums.length;
        int left = 0, right = n - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            // 收缩右边界
            if (nums[mid] < nums[right]) {
                right = mid;
            // 收缩左边界
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int lowerBound(int[] nums, int left, int right, int target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target){
                right = mid - 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```

**一次二分**

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            // 左半边有序
            if (nums[left] <= nums[mid]) {
                // target 在 left 和 mid 之间，收缩右边界
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                    // 收缩左边界
                } else {
                    left = mid + 1;
                }
            }
            // 右半边有序
            else {
                // target 在 mid 和 right 之间，收缩左边界
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                    // 收缩右边界
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }
}
```

## 优化
