# [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary)

## 思路

**求欧拉路径问题**

不是传统的回溯，欧拉路径是在递归的过程中反向构建路径。

**Hierholzer** 算法：
- 每次沿着未访问的边走到底；
- 到达死路后把**当前节点**加入结果；
- 回到上层继续补全路径。

因为需要访问每一个节点，所以当某个节点无路可走时，则该节点一定在路径最后。

```text
dfs(JFK)
  -> dfs(ATL)
       -> dfs(JFK)
            -> dfs(SFO)
                 -> dfs(ATL)
                      （无路可走） path = [ATL]
                 path = [SFO, ATL]
            path = [JFK, SFO, ATL]
       path = [ATL, JFK, SFO, ATL]
  path = [JFK, ATL, JFK, SFO, ATL]
```

## 解法

### 回溯

**优先队列**

```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, PriorityQueue<String>> graph = new HashMap<>();
        LinkedList<String> path = new LinkedList<>();

        // 1. 建图：使用最小堆保证字典序
        // 使用一个map来表示图，key是出发城市，value是目的城市的优先队列（小根堆）
        for (List<String> ticket : tickets) {
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.computeIfAbsent(from, k -> new PriorityQueue<>()).add(to);
        }

        // 2. 从 JFK 出发进行 DFS
        dfs(graph, "JFK", path);

        return path;
    }

    private void dfs(Map<String, PriorityQueue<String>> graph, String start, List<String> path) {
        PriorityQueue<String> nexts = graph.get(start);
        while (nexts != null && !nexts.isEmpty()) {
            // 选择
            String next = nexts.poll();
            // 递归
            dfs(graph, next, path);
        }
        // 回溯（头插法）
        path.addFirst(start);
    }
}
```

## 优化

