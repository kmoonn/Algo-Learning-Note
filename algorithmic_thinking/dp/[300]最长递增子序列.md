# [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence)

## 思路

最值问题：**求最长子序列**

dp 数组定义：**以 nums[i] 结尾的最长递增子序列**

## 解法

### dp

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;

        int[] dp = new int[n];
        Arrays.fill(dp, 1);

        int res = 1;

        // 穷举长度
        for (int i = 1; i < n; i++) {
            // 穷举 i 前面的元素
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    // 选或不选问题
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }

        return res;
    }
}
```

## 优化

### 二分查找

```java
private int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;

        // dp数组存储当前长度的递增子序列的最小末尾元素
        int[] dp = new int[n];
        int len = 0;

        for (int num : nums) {
            int left = 0, right = len;
            // 二分查找，找到第一个大于或等于当前num的位置
            // 快速找到每个数字应该插入的位置
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (dp[mid] < num) left = mid + 1;
                else right = mid;
            }
            dp[left] = num;  // 更新该位置的最小值
            if (left == len) len++;  // 如果当前数比所有的都大，延长序列
        }

        return len;  // 返回最长递增子序列的长度
    }
```