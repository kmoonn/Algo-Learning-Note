# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water)

## 思路

## 解法

### 单调栈

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        // 单调栈：存储柱子的下标，保证栈内下标对应的高度单调递减
        Deque<Integer> st = new ArrayDeque<>();

        for (int i = 0; i < height.length; i++) {
            int h = height[i];
            // 核心条件：当前柱子高度 ≥ 栈顶柱子高度 → 能形成凹槽，开始计算接水量
            while (!st.isEmpty() && h >= height[st.peek()]) {
                // 弹出栈顶：作为凹槽的「底部」
                int bottomIdx = st.pop();
                int bottomH = height[bottomIdx];
                // 栈空说明没有左边界，无法接水，直接退出当前循环
                if (st.isEmpty()) {
                    break;
                }
                // 栈顶剩余的元素：凹槽的「左边界」
                int leftIdx = st.peek();
                int leftH = height[leftIdx];
                // 凹槽的有效高度 = 左右边界的较小值 - 底部高度（只有正的才接水）
                int dh = Math.min(leftH, h) - bottomH;
                // 凹槽的宽度 = 当前下标（右边界） - 左边界下标 - 1
                int width = i - leftIdx - 1;
                // 累加当前凹槽的接水量
                ans += dh * width;
            }
            // 当前柱子下标入栈（保持栈的单调递减性）
            st.push(i);
        }
        return ans;
    }
}
```

### 双指针

某个位置能接的雨水量 = 该位置左右两侧最大高度的较小值 - 该位置的高度。

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        // 首尾指针
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            // 收缩指针
            // 计算左边雨水量
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                left++;
            // 计算右边雨水量    
            } else {
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
}
```

## 优化